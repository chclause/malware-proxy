#!/usr/bin/env python
""" Main module for the proxy """
import socket
import sys
import threading
import urlparse

# https://www.w3.org/Protocols/HTTP/1.0/spec.html#Methods #
VALID_HTTP_VERBS = [
    "POST",
    "HEAD",
    "PATCH",
    "PUT",
    "DELETE",
]

# Response messages
BAD_REQUEST = "Bad Request"
NOT_IMPL = "Not Implemented"
OK = "OK"

def main():
    """ All the logics """
    port = 0

    # Check the input
    num_args = len(sys.argv)
    if num_args > 2:
        print "Too many arguments.  This program only takes a port number"
        return
    elif num_args < 2:
        print "Too few arguments.  This program takes a port number"
        return
    else:
        try:
            port = int(sys.argv[1])
            if port < 0 or port > 65535:
                raise ValueError
        except ValueError:
            print "Input must be a valid port number"
            return

    server_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('', port))
    server_socket.listen(1)
    print "Proxy server is ready to receive"
    while True:
        # Receive the request from client
        connection_socket, addr = server_socket.accept()
        thread = threading.Thread(target=handle_connection, args=(connection_socket, addr))
        thread.start()



def handle_connection(conn_sock, addr):
    """ Handle an incoming connection """
    print 'Client connected at: {0}\n'.format(addr)
    try:
        while True:
            message = conn_sock.recv(1024)

            response = ''
            request_line = ''
            path = None
            hostname = None
            parsed_url = ''
            port = 80
            # Split up the message, remove whitespace entries caused by split
            parts = filter(None, message.split('\r\n'))

            if len(parts) < 1:
                # Invalid request
                response = response_message(400, BAD_REQUEST)
            else:
                request_line = parts[0].split(' ')

            if len(request_line) != 3:
                # Invalid request line
                response = response_message(400, BAD_REQUEST)
            elif request_line[0].upper() in VALID_HTTP_VERBS:
                # Valid request technically but not supported
                response = response_message(501, NOT_IMPL)
            elif request_line[0].upper() != "GET":
                response = response_message(400, BAD_REQUEST)
            elif 'HTTP' not in request_line[2].upper():
                # Invalid request line
                response = response_message(400, BAD_REQUEST)

            if '400' not in response and '501' not in response:
                parsed_url = urlparse.urlparse(request_line[1])
                path = parsed_url.path
                hostname = parsed_url.netloc
                if parsed_url.port:
                    port = parsed_url.port

            if not hostname and not path:
                # Bad request
                response = response_message(400, BAD_REQUEST) if '501' not in response else response_message(501, NOT_IMPL)
            elif not hostname and len(parts) > 1:
                header = ''
                parsed_header = None

                for p in parts:
                    h = p.split(' ')
                    if len(h) == 2:
                        if h[0].lower() == 'host:':
                            header = h
                            break
                if len(header) != 2:
                    # Bad header
                    response = response_message(400, BAD_REQUEST)
                if len(header) > 1:
                    parsed_header = urlparse.urlparse(header[1])
                    if not parsed_header.path:
                        response = response_message(400, BAD_REQUEST)
                    else:
                        hostname = parsed_header.path
            elif path and not hostname:
                hostname = path
            if '400' not in response and '501' not in response:
                if not path:
                    path = '/'
                if hostname == path:
                    path = '/'
                hostname = str(hostname).strip()
                path = str(path).strip()
                response = forward_request(hostname, path, port, parts[2:])
                #print "Sending: {0}".format(response.decode('utf-8'))
                conn_sock.send(response)
                #conn_sock.close()
            else:
                conn_sock.send(response)
                #print "Closing connection to client at: {0}\n".format(addr)
                #conn_sock.close()
    except Exception as err:
        print err
        print "Closing connection to client at: {0}\n".format(addr)
        conn_sock.close()
        return


def response_message(code, message):
    """ Format a response message """
    return "HTTP/1.0 {0} {1}\r\n\r\n".format(code, message)


def request_message(path, hostname, other_headers):
    """ Format a request """
    required = "GET {0} HTTP/1.0\r\n\r\nHost: {1}\r\n\r\nConnection: close\r\n\r\n".format(path, hostname)
    for header in other_headers:
        if 'keep-alive' not in header.lower() and 'accept-encoding' not in header.lower() and 'content-length' not in header.lower() and 'host' not in header.lower():
            h = header + '\r\n\r\n'
            required = required + h
    return required


def forward_request(hostname, path, port, other_headers):
    """ Forward a GET request to a remote server """
    sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
    sock.settimeout(8.0)
    try:
        print "Attempting to connect to: {0}\n".format(hostname)
        sock.connect((hostname, port))
        print "Connected"
        sock.send(request_message(path, hostname, other_headers))
        buffer = sock.recv(8196)
        size = 8196
        length = False
        if size > 8196:
            response = buffer + sock.recv(int(size))
        else:
            response = buffer
        if not length:
            data = sock.recv(1024)
            while len(data) != 0:
                response += data
                data = sock.recv(1024)

        return response
    except Exception as err:
        print err
        return response_message(400, BAD_REQUEST)


main()
