#!/usr/bin/env python
""" Main module for the proxy """
import hashlib
import requests
import socket
import sys
import threading
import urlparse


# https://www.w3.org/Protocols/HTTP/1.0/spec.html#Methods #
VALID_HTTP_VERBS = [
    "POST",
    "HEAD",
    "PATCH",
    "PUT",
    "DELETE",
]

# Response messages
BAD_REQUEST = "Bad Request"
NOT_IMPL = "Not Implemented"
OK = "OK"
API_KEY = 0

def main():
    """ All the logics """
    port = 0
    global API_KEY
    # Check the input, must have valid port and api key
    num_args = len(sys.argv)
    if num_args > 3:
        print "Too many arguments.  This program only takes a port number"
        return
    elif num_args < 3:
        print "Too few arguments.  This program takes a port number followed by an API key for VirusTotal"
        return
    else:
        try:
            port = int(sys.argv[1])
            if port < 0 or port > 65535:
                raise ValueError
            API_KEY = sys.argv[2]
        except ValueError:
            print "Input must be a valid port number"
            return

    server_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('', port))
    server_socket.listen(1)
    print "Proxy server is ready to receive"
    while True:
        # Receive the request from client
        connection_socket, addr = server_socket.accept()
        thread = threading.Thread(target=handle_connection, args=(connection_socket, addr))
        thread.start()



def handle_connection(conn_sock, addr):
    """ Handle an incoming connection """
    print 'Client connected at: {0}\n'.format(addr)
    try:
        while True:
            message = conn_sock.recv(1024)

            response = ''
            request_line = ''
            path = None
            hostname = None
            parsed_url = ''
            port = 80
            # Split up the message, remove whitespace entries caused by split
            parts = filter(None, message.split('\r\n'))

            if len(parts) < 1:
                # Invalid request
                response = response_message(400, BAD_REQUEST)
            else:
                request_line = parts[0].split(' ')

            if len(request_line) != 3:
                # Invalid request line
                response = response_message(400, BAD_REQUEST)
            elif request_line[0].upper() in VALID_HTTP_VERBS:
                # Valid request technically but not supported
                response = response_message(501, NOT_IMPL)
            elif request_line[0].upper() != "GET":
                response = response_message(400, BAD_REQUEST)
            elif 'HTTP' not in request_line[2].upper():
                # Invalid request line
                response = response_message(400, BAD_REQUEST)
            # get path and hostname
            if '400' not in response and '501' not in response:
                parsed_url = urlparse.urlparse(request_line[1])
                path = parsed_url.path
                hostname = parsed_url.netloc
                if parsed_url.port:
                    port = parsed_url.port

            if not hostname and not path:
                # Bad request
                response = response_message(400, BAD_REQUEST) if '501' not in response else response_message(501, NOT_IMPL)
            elif not hostname and len(parts) > 1:
                header = ''
                parsed_header = None
                # Extract host from headers if it was not a complete path
                for p in parts:
                    h = p.split(' ')
                    if len(h) == 2:
                        if h[0].lower() == 'host:':
                            header = h
                            break
                if len(header) != 2:
                    # Bad header
                    response = response_message(400, BAD_REQUEST)
                if len(header) > 1:
                    parsed_header = urlparse.urlparse(header[1])
                    if not parsed_header.path:
                        response = response_message(400, BAD_REQUEST)
                    else:
                        hostname = parsed_header.path
            elif path and not hostname:
                hostname = path
            if '400' not in response and '501' not in response:
                if not path:
                    path = '/'
                if hostname == path:
                    path = '/'
                hostname = str(hostname).strip()
                path = str(path).strip()
                # Forward the request to the remote server and send the response back to client
                response = forward_request(hostname, path, port, parts[2:])
                conn_sock.send(response)
            else:
                conn_sock.send(response)
    except Exception as err:
        print err
        print "Closing connection to client at: {0}\n".format(addr)
        conn_sock.close()
        return


def response_message(code, message):
    """ Format a response message """
    return "HTTP/1.0 {0} {1}\r\n".format(code, message)


def request_message(path, hostname, other_headers):
    """ Format a request """
    required = "GET {0} HTTP/1.0\r\n\r\nHost: {1}\r\n\r\nConnection: close\r\n\r\n".format(path, hostname)
    # Remove the undesirables
    for header in other_headers:
        if 'keep-alive' not in header.lower() and 'accept-encoding' not in header.lower() and 'content-length' not in header.lower() and 'host' not in header.lower():
            h = header + '\r\n\r\n'
            required = required + h
    return required


def forward_request(hostname, path, port, other_headers):
    """ Forward a GET request to a remote server """
    # Open a socket with remote host and set a timeout
    sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
    sock.settimeout(8.0)
    try:
        print "Attempting to connect to: {0}\n".format(hostname)
        sock.connect((hostname, port))
        print "Connected"
        sock.send(request_message(path, hostname, other_headers))
        buffer = sock.recv(8196)
        size = 8196
        length = False
        response = buffer

        # Keep trying to read data until it is all done
        if not length:
            data = sock.recv(1024)
            while len(data) != 0:
                response += data
                data = sock.recv(1024)
        print "Received\n"
        # Separate header from body
        content = response.split('\r\n\r\n')
        # Just return, might be an error or poorly formatted response
        if len(content) < 2:
            return response
        # Extract body
        body = content[1]
        # Calculate md5 checksum
        hashed_file = hashlib.md5(body).hexdigest()  
        print 'HASH: {0}\n'.format(hashed_file)
        # Send a request to VirusTotal
        print "Sending to scanner\n"
        scan_response = vt_get_request(hashed_file)
        print "Scan received\n"
        try:
            # Make sure the response is parsable, if not just return
            scan_response.json()
        except Exception:
            return response
        # Check if the response is 0
        if 'response_code' in scan_response.json():
            if scan_response.json()['response_code'] == 0:
                return response
        # Don't try to parse it
        if 'scans' not in scan_response.json():
            return response
        # Search the scans for malware detection
        scans = scan_response.json()['scans']
        for key in scans.keys():
            if scans[key]['detected']:
                print "FOUND\n"
                # Return 200, some headers, and the html below
                return response_message(200, OK) + 'Content-Type: text/html\r\nContent-Length: {0}\r\n'.format(len(virus_found_html())) + '\r\n\r\n' + virus_found_html()
        print "NOT FOUND\n"
        # Its all good
        return response
    except Exception as err:
        print err
        return response

def vt_get_request(resource):
    """ Takes an md5 checksum and makes properly formed GET
        requst to VirusTotal """

    # Code basically taken from VirusTotal's suggested public api usage
    url = 'https://www.virustotal.com/vtapi/v2/file/report'
    params = {'apikey': API_KEY, 'resource': resource}

    response = requests.get(url=url, params=params)
    return response

def virus_found_html():
    """ Return an html page when a virus is detect """
    message = '\
<html>\
<head>\
   <title></title>\
</head>\
<body>\
   <h1>Virus Detected</h1>\
   <p>Your browser sent a request that was formatted correctly.</p>\
   <p>However, the target server returned a file object that contained malware.</p>\
</body>\
</html>\r\n'
    return message

main()
