""" Main module for the proxy """
import socket
import sys
import urlparse

# https://www.w3.org/Protocols/HTTP/1.0/spec.html#Methods #
VALID_HTTP_VERBS = [
    "POST",
    "HEAD",
]

# Response messages
BAD_REQUEST = "Bad Request"
NOT_IMPL = "Not Implemented"
OK = "OK"

def main():
    """ All the logics """
    port = 0

    # Check the input
    num_args = len(sys.argv)
    if num_args > 2:
        print "Too many arguments.  This program only takes a port number"
        return
    elif num_args < 2:
        print "Too few arguments.  This program takes a port number"
        return
    else:
        try:
            port = int(sys.argv[1])
            if port < 0 or port > 65535:
                raise ValueError
        except ValueError:
            print "Input must be a valid port number"
            return

    server_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('', port))
    server_socket.listen(1)
    print "Server is ready to receive"
    while True:
        # Reveive the request from client
        connection_socket, addr = server_socket.accept()
        """
        message = connection_socket.recv(1024).decode()
        print message + " recieved from client at: {0}".format(addr)
        
        # Split message on spaces.  Should be length 3
        #   with [verb, url, http/1.0]
        parts = message.split(' ')
        print parts

        # Form response message
        response = response_message(200, "OK")
        if len(parts) != 3 and len(parts) != 5: 
            print "PARTS: " + str(len(parts))
            response = response_message(400, "Bad Request")
        elif parts[0].upper() in VALID_HTTP_VERBS:
            response = response_message(501, "Not Implemented")
        elif parts[0].upper() != "GET":
            print parts[0].upper()
            response = response_message(400, "Bad Request")
        elif parts[2].strip() != "HTTP/1.0":
            print parts[2].strip()
            response = response_message(400, "Bad Request")
        elif len(parts) == 5 and parts[3].lower() != "Host":
            response = response_message(400, "Bad Request")
        # Extract url information and add it to the Host header info if need be
        host_to_connect_to = parts[1]
        if len(parts) == 5:
            host_to_connect_to = parts[4] + parts[1]
        print "Connecting to: " + host_to_connect_to

        connection_socket.send(response)
        print "Closing connection to client at: {0}".format(addr)
        connection_socket.close()
        """
        handle_connection(connection_socket, addr)


def handle_connection(conn_sock, addr):
    """ Handle an incoming connection """
    try:
        while True:
            message = conn_sock.recv(1024).decode()
            print message + " recieved from client at: {0}\n".format(addr)

            response = ''
            path = None
            hostname = None
            parsed_url = ''
            port = 80

            parts = message.split(' ')
            if len(parts) != 3:
                # Invalid request line
                response = response_message(400, BAD_REQUEST)
            elif parts[0] in VALID_HTTP_VERBS:
                # Valid request technically but not supported
                response = response_message(501, NOT_IMPL)
            elif 'http' not in parts[2].lower():
                # Invalid request line
                response = response_message(400, BAD_REQUEST)

            if '400' not in response and '501' not in response:
                parsed_url = urlparse.urlparse(parts[1])
                path = parsed_url.path
                hostname = parsed_url.netloc
                if parsed_url.port:
                    port = parsed_url.port

            if not hostname and not path:
                # Bad request line
                response = response_message(400, BAD_REQUEST)
            elif not hostname:
                header = conn_sock.recv(1024).decode().split(' ')
                if len(header) != 2:
                    # Bad header
                    response = response_message(400, BAD_REQUEST)
                parsed_header = urlparse.urlparse(header[1])
                if not parsed_header.path:
                    # No hostname has been provided
                    response = response_message(400, BAD_REQUEST)
                hostname = parsed_header.path

            if '400' not in response and '501' not in response:
                hostname = str(hostname).strip()
                path = str(path).strip()
                response = forward_request(hostname, path, port)
                conn_sock.send(response)
            else:
                conn_sock.send(response)
    except Exception as err:
        conn_sock.send(response_message(400, BAD_REQUEST))
        print err.message
        print "Closing connection to client at: {0}\n".format(addr)
        conn_sock.close()


def response_message(code, message):
    """ Format a response message """
    return "HTTP/1.0 {0} {1}".format(code, message)


def request_message(path, hostname):
    """ Format a request """
    return "GET {path} HTTP/1.0\r\n\r\nHost: {hostname}\r\n\r\nConnection: close\r\n\r\n".format(path=path, hostname=hostname)


def forward_request(hostname, path, port):
    """ Forward a GET request to a remote server """
    sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
    try:
        sock.connect((hostname, port))
        sock.send(request_message(path, hostname))
        response = sock.recv(1024)
        print "Response from remote server: {0}\n".format(response.decode())
        return response
    except Exception as err:
        print err.message
        return response_message(400, BAD_REQUEST)



if __name__ == "__main__":
    main()
