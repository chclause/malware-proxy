""" Main module for the proxy """
import socket
import sys
import urlparse

# https://www.w3.org/Protocols/HTTP/1.0/spec.html#Methods #
VALID_HTTP_VERBS = [
    "POST",
    "HEAD",
]

# Response messages
BAD_REQUEST = "Bad Request"
NOT_IMPL = "Not Implemented"
OK = "OK"

def main():
    """ All the logics """
    port = 0

    # Check the input
    num_args = len(sys.argv)
    if num_args > 2:
        print "Too many arguments.  This program only takes a port number"
        return
    elif num_args < 2:
        print "Too few arguments.  This program takes a port number"
        return
    else:
        try:
            port = int(sys.argv[1])
            if port < 0 or port > 65535:
                raise ValueError
        except ValueError:
            print "Input must be a valid port number"
            return

    server_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server_socket.bind(('', port))
    server_socket.listen(1)
    print "Proxy server is ready to receive"
    while True:
        # Reveive the request from client
        connection_socket, addr = server_socket.accept()
        handle_connection(connection_socket, addr)


def handle_connection(conn_sock, addr):
    """ Handle an incoming connection """
    try:
        while True:
            message = conn_sock.recv(1024).decode()
            print message + " recieved from client at: {0}\n".format(addr)

            response = ''
            request_line = ''
            path = None
            hostname = None
            parsed_url = ''
            port = 80

            parts = message.split('\r\n')
            if len(parts) < 2:
                # Invalid request
                response = response_message(400, BAD_REQUEST)
            else:
                request_line = parts[0].split(' ')

            if len(request_line) != 3:
                # Invalid request line
                response = response_message(400, BAD_REQUEST)
            elif request_line[0] in VALID_HTTP_VERBS:
                # Valid request technically but not supported
                response = response_message(501, NOT_IMPL)
            elif request_line[0].upper() != "GET":
                response = response_message(400, BAD_REQUEST)
            elif 'http' not in request_line[2].lower():
                # Invalid request line
                response = response_message(400, BAD_REQUEST)

            if '400' not in response and '501' not in response:
                parsed_url = urlparse.urlparse(request_line[1])
                path = parsed_url.path
                hostname = parsed_url.netloc
                if parsed_url.port:
                    port = parsed_url.port

            if not hostname and not path:
                # Bad request line
                response = response_message(400, BAD_REQUEST)
            elif not hostname:
                header = parts[1].split(' ')
                if len(header) != 2:
                    # Bad header
                    response = response_message(400, BAD_REQUEST)
                parsed_header = urlparse.urlparse(header[1])
                if not parsed_header.path:
                    # No hostname has been provided
                    response = response_message(400, BAD_REQUEST)
                hostname = parsed_header.path

            if '400' not in response and '501' not in response:
                hostname = str(hostname).strip()
                path = str(path).strip()
                response = forward_request(hostname, path, port, parts[2:])
                conn_sock.send(response)
            else:
                conn_sock.send(response)
    except Exception as err:
        print err.message
        print "Closing connection to client at: {0}\n".format(addr)
        conn_sock.close()


def response_message(code, message):
    """ Format a response message """
    return "HTTP/1.0 {0} {1}".format(code, message)


def request_message(path, hostname, other_headers):
    """ Format a request """
    required = "GET {0} HTTP/1.0\r\n\r\nHost: {1}\r\n\r\nConnection: close\r\n\r\n".format(path, hostname)
    for header in other_headers:
        if header and 'keep-alive' not in header.lower():
            h = header + '\r\n\r\n'
            required = required + h
    return required


def forward_request(hostname, path, port, other_headers):
    """ Forward a GET request to a remote server """
    sock = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
    try:
        sock.connect((hostname, port))
        sock.send(request_message(path, hostname, other_headers))
        response = sock.recv(1024)
        print "Response from remote server: {0}\n".format(response.decode())
        return response
    except Exception as err:
        print err.message
        return response_message(400, BAD_REQUEST)



if __name__ == "__main__":
    main()
